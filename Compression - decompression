Hereâ€™s the full code to compress and decompress objects using GZIP for 
handling large data in the Spring Batch ExecutionContext:


---

Full Code for Compression and Decompression

1. Utility Class: CompressionUtils

import java.io.*;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

public class CompressionUtils {

    // Compress an object into a byte array
    public static byte[] compressObject(Object obj) throws IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        try (GZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);
             ObjectOutputStream objectOutputStream = new ObjectOutputStream(gzipOutputStream)) {
            objectOutputStream.writeObject(obj);
        }
        return byteArrayOutputStream.toByteArray();
    }

    // Decompress a byte array back into an object
    public static Object decompressObject(byte[] compressedData) throws IOException, ClassNotFoundException {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(compressedData);
        try (GZIPInputStream gzipInputStream = new GZIPInputStream(byteArrayInputStream);
             ObjectInputStream objectInputStream = new ObjectInputStream(gzipInputStream)) {
            return objectInputStream.readObject();
        }
    }
}


---

2. Example Usage in Spring Batch Tasklet

Tasklet to Compress and Store Data

import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class ReadAndCompressTasklet implements Tasklet {

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        // Simulated movie IDs (large data)
        List<String> movieIds = List.of("MOVIE_1", "MOVIE_2", "MOVIE_3", "MOVIE_4");

        // Compress the movie IDs
        byte[] compressedData = CompressionUtils.compressObject(movieIds);

        // Store compressed data in the ExecutionContext
        chunkContext.getStepContext()
                .getStepExecution()
                .getExecutionContext()
                .put("compressedMovieIds", compressedData);

        System.out.println("Tasklet 1: Movie IDs compressed and stored.");
        return RepeatStatus.FINISHED;
    }
}


---

Tasklet to Decompress and Process Data

import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class DecompressAndProcessTasklet implements Tasklet {

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        // Retrieve compressed data from ExecutionContext
        byte[] compressedData = (byte[]) chunkContext.getStepContext()
                .getStepExecution()
                .getExecutionContext()
                .get("compressedMovieIds");

        if (compressedData == null) {
            throw new IllegalStateException("No data found in ExecutionContext!");
        }

        // Decompress the movie IDs
        List<String> movieIds = (List<String>) CompressionUtils.decompressObject(compressedData);

        // Process the movie IDs
        for (String movieId : movieIds) {
            System.out.println("Tasklet 2: Processing " + movieId);
        }

        return RepeatStatus.FINISHED;
    }
}


---

How It Works

1. Compression (Tasklet 1):

The compressObject method serializes the object (e.g., a List<String>) and compresses it using GZIP.

The compressed data is stored in the ExecutionContext.



2. Decompression (Tasklet 2):

The decompressObject method retrieves the compressed byte array from the ExecutionContext.

It decompresses the data and deserializes it back into the original object.





---

Advantages

Reduces Serialized Size:

Compression minimizes the size of the data stored in the database (BATCH_JOB_EXECUTION_CONTEXT).


Easy Retrieval:

Decompression restores the original object with minimal overhead.




---

Example Output

1. Tasklet 1 compresses and stores the data:

Tasklet 1: Movie IDs compressed and stored.


2. Tasklet 2 decompresses and processes the data:

Tasklet 2: Processing MOVIE_1
Tasklet 2: Processing MOVIE_2
Tasklet 2: Processing MOVIE_3
Tasklet 2: Processing MOVIE_4




---

Would you like additional help to integrate this into your Spring Batch job configuration?

